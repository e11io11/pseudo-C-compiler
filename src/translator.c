/**
 * @author Antonin JEAN
 * @email ofghanirre@gmail.com
 * @create date 2022-04-05 16:48:52
 * @modify date 2022-04-05 16:48:52
 * @desc Src file related to asm translation
 */

#include "../inc/translator.h"

#define SIZE_DECL_INT "dd"
#define SIZE_DECL_CHAR "db"
#define SIZE_INT "dword"
#define SIZE_CHAR "byte"

#define __ASM_PATTERN_HEADER \
    "; FILE AUTO GENERATED BY COMPILER\n"                   \
    "; --------------------\n"                              \
    "; Translator tpc -> asm\n"                             \
    ";\n"                                                   \
    "; authors : Elliott FALGUEROLLE & Antonin JEAN\n\n"

#define __ASM_PATTERN_MAIN_FOOTER\
    "; End of Program: Print -1 as Fine-Output\n"           \
    "mov rdi, -1\n"                                       \
    "call printInt\n"                                     \
    "mov rax, 60\n"                                         \
    "mov rdi, 0\n"                                          \
    "syscall"

#define __ASM_PATTERN_FNC_HEADER \
    "push rbp\n" \
    "mov rbp, rsp\n"

#define __ASM_PATTERN_FNC_FOOTER \
    "mov rsp, rbp\n" \
    "pop rbp\n" \
    "ret\n\n"


FILE * asm_file = NULL;

FILE * getFile() { return asm_file; }

void __initAsmFile(const char * name, programSymbolTables symbolTabs, Node* tree) {
    char filename[256] = "\0";
    sprintf(filename, "%s.asm", name);
    asm_file = fopen(filename, "w");
    if (!asm_file) raiseError("__initAsmFile : asm_file failed at creation");
    fprintf(asm_file, __ASM_PATTERN_HEADER);
    initGlobalVariables(symbolTabs);
    initTextSection(symbolTabs);  
    initFunctions(symbolTabs);
    fclose(asm_file);
}

void initTextSection(programSymbolTables symbolTabs) {
    fprintf(asm_file, "section .text\n");
    if (findHashElem(symbolTabs.globals, "main") != NULL)
        fprintf(asm_file, "global main\n");
    fprintf(asm_file, "\n");

}

void initGlobalVariables(programSymbolTables symbolTabs) {
    HashElem* el;
    int amount = symbolTabs.globals.elemAmount;
    HashElem ** elements = HashTableValues(&(symbolTabs.globals));
    int totalOffset = 0;
    fprintf(asm_file, "section .data\n");
    for (int i = 0; i < amount; i++) {
        el = elements[i];
        if (el->h_val.type != _type_function) {
            el->h_val.pileOffset = totalOffset;
            totalOffset += el->h_val.val.size;
            fprintf(asm_file, "%s: %s 0\n", el->h_key, 
                el->h_val.type == _type_char ? SIZE_DECL_CHAR : SIZE_DECL_INT);
        }
    }
    free(elements);
}


void initMain(programSymbolTables symbolTabs, functionSymbolTables* func) {
    fprintf(asm_file, "main:\n");
    initFunctionVariables(symbolTabs, func);
    initFunctionBody(symbolTabs, func, func->root->firstChild->nextSibling);
    fprintf(asm_file, "%s", __ASM_PATTERN_MAIN_FOOTER);
    fprintf(asm_file, "\n\n");
}


void initFunctionVariables(programSymbolTables symbolTabs, functionSymbolTables* func) {
    HashElem* el;
    int totalOffset = 0;
    int parAmount = func->parameters.elemAmount;
    HashElem ** elements = HashTableValues(&(func->parameters));
    for (int i = 0; i < parAmount; i++) {
        el = elements[i];
        el->h_val.pileOffset = totalOffset;
        totalOffset += el->h_val.val.size;
        //todo, set parameter variables to their values
    }
    free(elements);
    int varAmount = func->values.elemAmount;
    elements = HashTableValues(&(func->values));
    for (int i = 0; i < varAmount; i++) {
        el = elements[i];
        el->h_val.pileOffset = totalOffset;
        totalOffset += el->h_val.val.size;
    }
    free(elements);
    fprintf(asm_file, "add rsp, %i\n", totalOffset);
}

void initFunctions(programSymbolTables symbolTabs) {
    functionSymbolTables* func = symbolTabs.functions;
    while (func != NULL) {
        if (strcmp(func->name, "main") == 0)
            initMain(symbolTabs, func);
        else {
            fprintf(asm_file, "%s:\n", func->name);
            fprintf(asm_file, "%s", __ASM_PATTERN_FNC_HEADER);
            initFunctionVariables(symbolTabs, func); 
            initFunctionBody(symbolTabs, func, func->root->firstChild->nextSibling);
            fprintf(asm_file, "%s\n", __ASM_PATTERN_FNC_FOOTER);    
        }
        func = func->next;
    }
}

void initAssign(programSymbolTables symbolTabs, functionSymbolTables* func, Node* assign) {
    Node* node;
    node = findLabelInTree(assign->firstChild, ident);
    char* var_ident = node->value.ident;

    //todo: compute value to assign

    HashElem* var = findHashElem(func->values, var_ident);
    if (var == NULL)
        var = findHashElem(func->parameters, var_ident);
    if (var != NULL) {
        fprintf(asm_file, "pop %s [rbp-%i]\n", 
            var->h_val.type == _type_char ? SIZE_CHAR : SIZE_INT,
            var->h_val.pileOffset);
            return;
    }

    var = findHashElem(symbolTabs.globals, var_ident);
    if (var != NULL) {
        fprintf(asm_file, "pop %s [rsp+%i]\n", 
            var->h_val.type == _type_char ? SIZE_CHAR : SIZE_INT,
            var->h_val.pileOffset);
    }
    

    
}

void initFunctionBody(programSymbolTables symbolTabs, functionSymbolTables* func, Node* body) {
    Node* node = body->firstChild;
    while (node != NULL) {
        switch (node->label) {
        case assign:
            initAssign(symbolTabs, func, node);
            break;
        
        default:
            break;
        }

        node = node->nextSibling;
    }
    
}

