/**
 * @author Antonin JEAN
 * @email ofghanirre@gmail.com
 * @create date 2022-04-05 16:48:52
 * @modify date 2022-04-05 16:48:52
 * @desc Src file related to asm translation
 */

#include "../inc/translator.h"

#define SIZE_DECL_INT "dd"
#define SIZE_DECL_CHAR "db"
#define SIZE_INT "dword"
#define SIZE_CHAR "byte"
#define SIZE_RAX_INT "eax"
#define SIZE_RAX_CHAR "al"

#define __ASM_PATTERN_HEADER \
    "; FILE AUTO GENERATED BY COMPILER\n"                   \
    "; --------------------\n"                              \
    "; Translator tpc -> asm\n"                             \
    ";\n"                                                   \
    "; authors : Elliott FALGUEROLLE & Antonin JEAN\n\n"

#define __ASM_PATTERN_MAIN_FOOTER\
    "\tmov rax, 60\n"                                         \
    "\tmov rdi, 0\n"                                          \
    "\tsyscall"

#define __ASM_PATTERN_FNC_HEADER \
    "\t; Function Header\n" \
    "\tpush rbp\n" \
    "\tmov rbp, rsp\n" \
    "\tpush rbx\n\n"


#define __ASM_PATTERN_FNC_FOOTER \
    "\n\t; Function Footer\n" \
    "\tpop rbx\n" \
    "\tmov rsp, rbp\n" \
    "\tpop rbp\n" \
    "\tret\n\n"

#define __ASM_PATTERN_EXPR_HEADER \
    "\tpop rbx\n" \
    "\tpop rax\n"

#define __ASM_PATTERN_DIV_HEADER \
    "\txor rdx, rdx\n" \
    "\tpop rax\n" \
    "\tpop rbx\n"

#define __ASM_FUNCTION_IDENT "\t"

FILE * asm_file = NULL;

FILE * getFile() { return asm_file; }

int label_id = 0;

char* parameters_[6] = {"rdi", "rsi", "rdx", "rcx", "r8", "r9"};
char* parameters_int[6] = {"edi", "esi", "edx", "ecx", "r8d", "r9d"};
char* parameters_char[6] = {"dil", "sil", "dl", "cl", "r8b", "r9b"};

void __initAsmFile(const char * name, programSymbolTables symbolTabs, Node* tree) {
    char filename[256] = "\0";
    sprintf(filename, "%s.asm", name);
    asm_file = fopen(filename, "w");
    if (!asm_file) raiseError("__initAsmFile : asm_file failed at creation");
    fprintf(asm_file, __ASM_PATTERN_HEADER);
    initGlobalVariables(symbolTabs);
    initTextSection(symbolTabs);  
    initFunctions(symbolTabs);
    fclose(asm_file);
}

void initTextSection(programSymbolTables symbolTabs) {
    fprintf(asm_file, "section .text\nextern printInt\n");
    if (findHashElem(symbolTabs.globals, "main") != NULL)
        fprintf(asm_file, "global _start\n");
    fprintf(asm_file, "\n");

}

void initGlobalVariables(programSymbolTables symbolTabs) {
    HashElem* el;
    int amount = symbolTabs.globals.elemAmount;
    if (amount > 0) {
        HashElem ** elements = HashTableValues(&(symbolTabs.globals));
        int totalOffset = 0;
        for (int i = 0; i < amount; i++) {
            el = elements[i];
            if (el->h_val.type != _type_function) {
                el->h_val.pileOffset = totalOffset;
                totalOffset += el->h_val.val.size;
            }
        }
        fprintf(asm_file, "section .bss\n");
        fprintf(asm_file, "section .bss\nglobal_vars: resb %i\n", totalOffset);
        free(elements);
    }
}


void initMain(programSymbolTables symbolTabs, functionSymbolTables* func) {
    fprintf(asm_file, "_start:\n\tmov rbp, rsp\n");
    initFunctionVariables(symbolTabs, func);
    initFunctionBody(symbolTabs, func, func->root->firstChild->nextSibling);
    fprintf(asm_file, "%s\n\n", __ASM_PATTERN_MAIN_FOOTER);
}


void initFunctionVariables(programSymbolTables symbolTabs, functionSymbolTables* func) {
    HashElem* el;
    int totalOffset = 0;
    int parAmount = func->parameters.elemAmount;
    HashElem ** elements = HashTableValues(&(func->parameters));
    for (int i = 0; i < parAmount; i++) {
        el = elements[i];
        el->h_val.pileOffset = totalOffset;
        /*
        if (i < 6)
            fprintf(asm_file, "\tmov %s [rbp-%i], %s\n",
                el->h_val.type == _type_char ? SIZE_CHAR : SIZE_INT,
                el->h_val.pileOffset,
                el->h_val.type == _type_char ? parameters_char[i] : parameters_int[i]);
        */
        totalOffset += el->h_val.val.size;
    }
    free(elements);


    int varAmount = func->values.elemAmount;
    elements = HashTableValues(&(func->values));
    for (int i = 0; i < varAmount; i++) {
        el = elements[i];
        el->h_val.pileOffset = totalOffset;
        totalOffset += el->h_val.val.size;
    }
    free(elements);
    fprintf(asm_file, "\tsub rsp, %i\n", totalOffset);
    Node* fnc_node = func->root->firstChild->firstChild->nextSibling->nextSibling->firstChild; //first parameter
    for (int i = 0; i < 6 && i < func->parameters.elemAmount; i++) {
        el = findHashElem(func->parameters, fnc_node->firstChild->value.ident);
        fprintf(asm_file, "\tmov %s [rbp-%i], %s\n",
            el->h_val.type == _type_char ? SIZE_CHAR : SIZE_INT,
            el->h_val.pileOffset, 
            strcmp(fnc_node->value.comp, "char") == 1 ? parameters_char[i] : parameters_int[i]);
        fnc_node = fnc_node->nextSibling;
    }
}

void initFunctions(programSymbolTables symbolTabs) {
    functionSymbolTables* func = symbolTabs.functions;
    while (func != NULL) {
        if (strcmp(func->name, "main") == 0)
            initMain(symbolTabs, func);
        else {
            fprintf(asm_file, "%s:\n", func->name);
            fprintf(asm_file, "%s", __ASM_PATTERN_FNC_HEADER);
            initFunctionVariables(symbolTabs, func); 
            initFunctionBody(symbolTabs, func, func->root->firstChild->nextSibling);
            fprintf(asm_file, "%s\n", __ASM_PATTERN_FNC_FOOTER);    
        }
        func = func->next;
    }
}

void initFunctionCall(programSymbolTables symbolTabs, functionSymbolTables* func, Node* node) {
    char* fnc_ident = node->value.ident;
    node = node->firstChild->firstChild;
    initRValue(symbolTabs, func, node);
    functionSymbolTables* called_func = symbolTabs.functions;
    while (called_func != NULL && strcmp(called_func->name, fnc_ident) != 0) {
        called_func = called_func->next;
    }

    if (called_func == NULL) return; /* FOR BUILTIN  FUNCTIONS */

    for (int i = 0; i < called_func->parameters.elemAmount; i++) {
        fprintf(asm_file, "\tpop %s\n", parameters_[i]);
    }
    fprintf(asm_file, "\tcall %s\n\tpush rax\n", fnc_ident);
}

void initIdent(programSymbolTables symbolTabs, functionSymbolTables* func, Node* node) {
    //ident is a function
    if (node->firstChild != NULL) {
        initFunctionCall(symbolTabs, func, node);
        return;
    }

    char* ident_val = node->value.ident;
    HashElem* var = findHashElem(func->values, ident_val);
    if (var == NULL)
        var = findHashElem(func->parameters, ident_val);
    //var is a function argument or local variable
    if (var != NULL) {
        fprintf(asm_file, "\tmov %s, %s [rbp-%i]\n\tpush rax\n",
            var->h_val.type == _type_char ? SIZE_RAX_CHAR : SIZE_RAX_INT, 
            var->h_val.type == _type_char ? SIZE_CHAR : SIZE_INT,
            var->h_val.pileOffset);
            return;
    }
    //var is a global variable
    var = findHashElem(symbolTabs.globals, ident_val);
    if (var != NULL) {
        fprintf(asm_file, "\tmov %s, %s [global_vars+%i]\n\tpush rax\n",
            var->h_val.type == _type_char ? SIZE_RAX_CHAR : SIZE_RAX_INT, 
            var->h_val.type == _type_char ? SIZE_CHAR : SIZE_INT,
            var->h_val.pileOffset);
    }
}

void initAddSub(programSymbolTables symbolTabs, functionSymbolTables* func, Node* node) {
        initRValue(symbolTabs, func, node->firstChild);
        fprintf(asm_file, "%s\t%s rax, rbx\n\tpush rax\n",
            __ASM_PATTERN_EXPR_HEADER, 
            node->value.byte == '+' ? "add" : "sub");
}

void initDivStar(programSymbolTables symbolTabs, functionSymbolTables* func, Node* node) {
        initRValue(symbolTabs, func, node->firstChild);
        if (node->value.byte == '*')
            fprintf(asm_file, "%s\timul rax, rbx\n\tpush rax\n", __ASM_PATTERN_EXPR_HEADER);
        else
            fprintf(asm_file, "%s\txor rdx, rdx\n\tidiv rbx\n\tpush rax\n", __ASM_PATTERN_EXPR_HEADER);
}

void initOrderEq(programSymbolTables symbolTabs, functionSymbolTables* func, Node* node) {
        initRValue(symbolTabs, func, node->firstChild);
        char jmp[4] = "j";
        if (node->label == eq) {
            switch(node->value.comp[0]) {
                case '!': jmp[2] = 'n'; jmp[2] = 'e'; jmp[3] = '\0';
                default: jmp[1] = 'e'; jmp[2] = '\0'; 
            }
        }
        else {
            switch(node->value.comp[0]) {
                case '>': jmp[1] = 'g'; break;
                case '<': jmp[1] = 'l'; break;
                default: jmp[1] = 'e'; break;
            }
            switch(node->value.comp[1]) {
                case '=': jmp[2] = 'e'; jmp[3] = '\0'; break;
                default: jmp[2] = '\0'; break;
            }
        }
        fprintf(asm_file, "%s\tmov rdx, 1\n\tcmp rax, rbx\n\t%s label_%i\n\tmov rdx, 0\n\tlabel_%i:\n\tpush rdx\n",
            __ASM_PATTERN_EXPR_HEADER,
            jmp,
            label_id,
            label_id);
        label_id += 1;
}

void initOr(programSymbolTables symbolTabs, functionSymbolTables* func, Node* node) {
        initRValue(symbolTabs, func, node->firstChild);
        fprintf(asm_file, "%s\tmov rdx, 1\n\tcmp rax, 0\n\tjne label_%i\n\
    cmp rbx, 0\n\tjne label_%i\n\
    mov rdx, 0\n\tlabel_%i:\n\tpush rdx\n",
            __ASM_PATTERN_EXPR_HEADER,
            label_id,
            label_id,
            label_id);
        label_id += 1;
}

void initAnd(programSymbolTables symbolTabs, functionSymbolTables* func, Node* node) {
        initRValue(symbolTabs, func, node->firstChild);
        fprintf(asm_file, "%s\tmov rdx, 0\n\tcmp rax, 0\n\tje label_%i\n\
    cmp rbx, 0\n\tje label_%i\n\
    mov rdx, 1\n\tlabel_%i:\n\tpush rdx\n",
            __ASM_PATTERN_EXPR_HEADER,
            label_id,
            label_id,
            label_id);
        label_id += 1;
}

void initNot(programSymbolTables symbolTabs, functionSymbolTables* func, Node* node) {
        initRValue(symbolTabs, func, node->firstChild);
        fprintf(asm_file, "\tpop rax\n\tmov rdx, 1\n\tcmp rax, 0\n\tje label_%i\n\
    mov rdx, 0\n\tlabel_%i:\n\tpush rdx\n",
            label_id,
            label_id);
        label_id += 1;
}


void initRValue(programSymbolTables symbolTabs, functionSymbolTables* func, Node* node) {
    while (node != NULL) {
        switch (node->label) {
        case ident :
            initIdent(symbolTabs, func, node);
            break;
        case num :
            fprintf(asm_file, "\tpush %i\n", node->value.num);
            break;
        case character:
            fprintf(asm_file, "\tpush %i\n", node->value.byte);
            break;
        case addsub:
            initAddSub(symbolTabs, func, node);
            break;
        case divstar:
            initDivStar(symbolTabs, func, node);
            break;
        case order:
            initOrderEq(symbolTabs, func, node);
            break;
        case eq:
            initOrderEq(symbolTabs, func, node);
            break;
        case and:
            initAnd(symbolTabs, func, node);
            break;
        case or:
            initOr(symbolTabs, func, node);
            break;
        case not:
            initNot(symbolTabs, func, node);
            break;
        default:
            printf("something hasn't been implemented yet :(\n");
            break;
        }
        node = node->nextSibling;
    }
    
}

void initReturn(programSymbolTables symbolTabs, functionSymbolTables* func, Node* node) {
    initRValue(symbolTabs, func, node->firstChild);
    if (strcmp(func->name, "main") != 0)
        fprintf(asm_file, "\tpop rax\n%s", __ASM_PATTERN_FNC_FOOTER);
    
}

void initAssign(programSymbolTables symbolTabs, functionSymbolTables* func, Node* node) {
    node = findLabelInTree(node->firstChild, ident);

    initRValue(symbolTabs, func, node->nextSibling);

    fprintf(asm_file, "\tpop rax\n");

    char* ident_val = node->value.ident;
    HashElem* var = findHashElem(func->values, ident_val);
    if (var == NULL)
        var = findHashElem(func->parameters, ident_val);

    //var is a function argument or local variable
    if (var != NULL) {
        fprintf(asm_file, "\tmov %s [rbp-%i], %s\n", 
            var->h_val.type == _type_char ? SIZE_CHAR : SIZE_INT,
            var->h_val.pileOffset,
            var->h_val.type == _type_char ? SIZE_RAX_CHAR : SIZE_RAX_INT);
            return;
    }
    //var is a global variable
    var = findHashElem(symbolTabs.globals, ident_val);
    if (var != NULL) {
        fprintf(asm_file, "\tmov %s [global_vars+%i], %s\n", 
            var->h_val.type == _type_char ? SIZE_CHAR : SIZE_INT,
            var->h_val.pileOffset,
            var->h_val.type == _type_char ? SIZE_RAX_CHAR : SIZE_RAX_INT);
    }
}

void initFunctionBody(programSymbolTables symbolTabs, functionSymbolTables* func, Node* node) {
    node = node->firstChild;
    while (node != NULL) {
        switch (node->label) {
        case assign:
            initAssign(symbolTabs, func, node);
            break;
        case return_:
            initReturn(symbolTabs, func, node);
        default:
            break;
        }

        node = node->nextSibling;
    }
    
}

